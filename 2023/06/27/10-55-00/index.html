

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="小星">
  <meta name="keywords" content="">
  
    <meta name="description" content="这是小星学DSA系列的第六篇，我会记录我学习的过程与理解，希望能够帮到你。 本篇文章的完整思维导图如下。  链表定义链表是一种常见的数据结构，用于存储和组织数据。它由一系列节点组成，每个节点都包含一个数据元素和一个指向下一个节点的指针。  链表概念 节点：链表中的基本单元，每个节点包含一个数据元素和一个指向下一个节点的指针。 头节点：链表的起始节点，通过头节点可以访问整个链表。 尾节点：链表的最后">
<meta property="og:type" content="article">
<meta property="og:title" content="小星学DSA丨链表、哈希表与堆">
<meta property="og:url" content="http://rainystar.site/2023/06/27/10-55-00/index.html">
<meta property="og:site_name" content="小星code">
<meta property="og:description" content="这是小星学DSA系列的第六篇，我会记录我学习的过程与理解，希望能够帮到你。 本篇文章的完整思维导图如下。  链表定义链表是一种常见的数据结构，用于存储和组织数据。它由一系列节点组成，每个节点都包含一个数据元素和一个指向下一个节点的指针。  链表概念 节点：链表中的基本单元，每个节点包含一个数据元素和一个指向下一个节点的指针。 头节点：链表的起始节点，通过头节点可以访问整个链表。 尾节点：链表的最后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://rainystar.site/images/posts/list/xmind.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%201.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%202.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%203.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%204.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%205.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%206.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%207.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%208.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%209.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%2010.png">
<meta property="og:image" content="http://rainystar.site/images/posts/list/Untitled%2011.png">
<meta property="article:published_time" content="2023-06-27T02:55:00.000Z">
<meta property="article:modified_time" content="2023-06-27T02:57:50.086Z">
<meta property="article:author" content="小星">
<meta property="article:tag" content="DSA">
<meta property="article:tag" content="哈希表">
<meta property="article:tag" content="链表">
<meta property="article:tag" content="堆">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="http://rainystar.site/images/posts/list/xmind.png">
  
  
  
  <title>小星学DSA丨链表、哈希表与堆 - 小星code</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"rainystar.site","root":"/","version":"1.9.4","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  

  

  



  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小星code</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/images/cover/cover.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="小星学DSA丨链表、哈希表与堆"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-06-27 10:55" pubdate>
          2023年6月27日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          9.7k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          81 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">小星学DSA丨链表、哈希表与堆</h1>
            
            
              <div class="markdown-body">
                
                <p>这是小星学DSA系列的第六篇，我会记录我学习的过程与理解，希望能够帮到你。</p>
<p>本篇文章的完整思维导图如下。</p>
<p><img src="/images/posts/list/xmind.png" srcset="/img/loading.gif" lazyload alt="链表、哈希表与堆.png"></p>
<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>链表是一种常见的数据结构，用于存储和组织数据。它由一系列节点组成，每个节点都包含一个数据元素和一个指向下一个节点的指针。</p>
<p><img src="/images/posts/list/Untitled.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="链表概念"><a href="#链表概念" class="headerlink" title="链表概念"></a>链表概念</h3><ul>
<li>节点：链表中的基本单元，每个节点包含一个数据元素和一个指向下一个节点的指针。</li>
<li>头节点：链表的起始节点，通过头节点可以访问整个链表。</li>
<li>尾节点：链表的最后一个节点，其指针指向空值（None）。</li>
</ul>
<h3 id="链表的表示"><a href="#链表的表示" class="headerlink" title="链表的表示"></a>链表的表示</h3><p>链表通常由头节点表示，因此无需定义链表数据结构，只需定义链表的节点结构即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span><br>&#123;<br>  <span class="hljs-type">int</span> data;<br>  <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>通过该数据结构可以访问节点的数据与下一节点。</p>
<h2 id="链表的操作"><a href="#链表的操作" class="headerlink" title="链表的操作"></a>链表的操作</h2><p>下面介绍链表的基础操作：遍历、插入、删除、查找、排序</p>
<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>由于链表为链式结构，其遍历非常简单，直接依次访问即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">traverseLinkedList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>    Node* current = head;  <span class="hljs-comment">// 从头节点开始遍历</span><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123; <br>        std::cout &lt;&lt; current-&gt;data &lt;&lt; <span class="hljs-string">&quot; &quot;</span>; <br>        current = current-&gt;next;  <span class="hljs-comment">// 移动到下一个节点</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>链表的插入分为三种：插入头节点，插入中间节点，插入尾部节点</p>
<ul>
<li>插入头节点</li>
</ul>
<p>此时使新创建的节点指向原头节点，并将该节点作为新的头节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtHead</span><span class="hljs-params">(Node*&amp; head, <span class="hljs-type">int</span> newData)</span> </span>&#123;<br>    Node* newNode = <span class="hljs-keyword">new</span> Node&#123;newData, head&#125;;  <span class="hljs-comment">// 创建新节点，并使其指向原头节点</span><br>    head = newNode;  <span class="hljs-comment">// 更新头节点为新节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>插入某个节点的后面</li>
</ul>
<p>此时使用原节点的后继节点作为新节点的后继节点，并使新节点成为原节点的后继节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAfter</span><span class="hljs-params">(Node* prevNode, <span class="hljs-type">int</span> newData)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prevNode == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    Node* newNode = <span class="hljs-keyword">new</span> Node&#123;newData, prevNode-&gt;next&#125;;  <span class="hljs-comment">// 创建新节点，并使其指向原前一个节点的下一个节点</span><br>    prevNode-&gt;next = newNode;  <span class="hljs-comment">// 更新前一个节点的指针，指向新节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>插入尾部节点</li>
</ul>
<p>找到原尾部节点，并直接插入新节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insertAtTail</span><span class="hljs-params">(Node*&amp; head, <span class="hljs-type">int</span> newData)</span> </span>&#123;<br>    Node* newNode = <span class="hljs-keyword">new</span> Node&#123;newData, <span class="hljs-literal">nullptr</span>&#125;;  <span class="hljs-comment">// 创建新节点，指向nullptr</span><br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        head = newNode;  <span class="hljs-comment">// 如果链表为空，则新节点即为头节点</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Node* current = head;<br>    <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        current = current-&gt;next;  <span class="hljs-comment">// 找到最后一个节点</span><br>    &#125;<br><br>    current-&gt;next = newNode;  <span class="hljs-comment">// 将新节点连接到最后一个节点</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>同样的，根据删除位置，链表的删除也可以分为三种：删除头部节点，删除中间节点，删除尾部节点</p>
<ul>
<li>删除头节点</li>
</ul>
<p>删除头节点，并使用头节点的后继节点作为新的头节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtHead</span><span class="hljs-params">(Node*&amp; head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list is empty.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Node* temp = head;<br>    head = head-&gt;next;  <span class="hljs-comment">// 更新头节点为下一个节点</span><br>    <span class="hljs-keyword">delete</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>删除中间节点</li>
</ul>
<p>将中间节点的前序节点直接指向中间节点的后继节点，并删除中间节点</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAfter</span><span class="hljs-params">(Node* prevNode)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (prevNode == <span class="hljs-literal">nullptr</span> || prevNode-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Previous node or next node cannot be nullptr.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Node* temp = prevNode-&gt;next;<br>    prevNode-&gt;next = temp-&gt;next;  <span class="hljs-comment">// 更新前一个节点的指针，跳过待删除节点</span><br>    <span class="hljs-keyword">delete</span> temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>删除尾部节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">deleteAtTail</span><span class="hljs-params">(Node*&amp; head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Linked list is empty.&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (head-&gt;next == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">delete</span> head;<br>        head = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    Node* prevNode = <span class="hljs-literal">nullptr</span>;<br>    Node* current = head;<br>    <span class="hljs-keyword">while</span> (current-&gt;next != <span class="hljs-literal">nullptr</span>) &#123;<br>        prevNode = current;<br>        current = current-&gt;next;<br>    &#125;<br><br>    <span class="hljs-keyword">delete</span> current;<br>    prevNode-&gt;next = <span class="hljs-literal">nullptr</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p>由于链表的链式结构，因此不能直接获取查找的值，需要通过链表的遍历来实现链表的查找</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">Node* <span class="hljs-title">searchLinkedList</span><span class="hljs-params">(Node* head, <span class="hljs-type">int</span> target)</span> </span>&#123;<br>    Node* current = head;<br><br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">if</span> (current-&gt;data == target) &#123;<br>            <span class="hljs-keyword">return</span> current;  <span class="hljs-comment">// 找到目标节点，返回节点指针</span><br>        &#125;<br>        current = current-&gt;next;  <span class="hljs-comment">// 移动到下一个节点</span><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 未找到目标节点，返回nullptr</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="链表的分类"><a href="#链表的分类" class="headerlink" title="链表的分类"></a>链表的分类</h2><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><img src="/images/posts/list/Untitled%201.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><img src="/images/posts/list/Untitled%202.png" srcset="/img/loading.gif" lazyload></p>
<p>双向链表中含有两个指针,prev&amp;next，因此再进行操作时，需要修改双向的指针</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> &#123;<br>    <span class="hljs-type">int</span> data;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *next;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">node</span> *prev;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p><img src="/images/posts/list/Untitled%203.png" srcset="/img/loading.gif" lazyload></p>
<p>环形链表即将单向链表的尾节点的next指针指向头节点</p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p><strong>跳表是对有序链表的改进</strong>，用于在有序链表中进行快速查找和插入操作。</p>
<p>跳表通过在原始有序链表上添加多级索引来加速查找。这些索引层次之间通过跳跃链接连接起来，使得查找可以跳过部分元素，从而减少比较的次数，提高查询效率。最底层是原始有序链表，而每个上一级索引都是前一级索引的子集。通常情况下，跳表的底层索引包含链表中的所有元素。</p>
<p><img src="/images/posts/list/Untitled%204.png" srcset="/img/loading.gif" lazyload></p>
<p>因此，跳表的节点可以定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">SkipListNode</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    SkipListNode** forward;  <span class="hljs-comment">// 指向下一个节点的指针数组</span><br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>假如原始链表包含n个元素，每两个结点抽出一个结点作为上一级索引的结点</p>
<blockquote>
<p>则空间复杂度为$（n+n&#x2F;2+n&#x2F;4+..+2 &#x3D;n-2)&#x3D;\mathcal{O}(n)$</p>
</blockquote>
<p>跳表的最高层至少有两个元素，满足$h &#x3D; log_{2}n$</p>
<blockquote>
<p>对每层索引，至多遍历三个元素就会下放，因此时间复杂度为$3*log_2n &#x3D; \mathcal{O}(logn)$</p>
</blockquote>
<h3 id="查找-1"><a href="#查找-1" class="headerlink" title="查找"></a>查找</h3><p>跳表的查找如下实现：</p>
<ul>
<li>从顶层索引开始，在索引层级上遍历，直到找到大于等于目标的节点；</li>
<li>根据上一节点记载的forward数据来到下一层；</li>
<li>返回底层链表中找到的节点</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">SkipListNode* <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-type">int</span> target)</span> </span>&#123;<br>        SkipListNode* current = head;<br><br>        <span class="hljs-comment">// 从最高层级开始查找</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> lvl = level; lvl &gt;= <span class="hljs-number">0</span>; lvl--) &#123;<br>						<span class="hljs-comment">// 在该层级上找到小于它的最大节点</span><br>            <span class="hljs-keyword">while</span> (current-&gt;forward[lvl] != <span class="hljs-literal">nullptr</span> &amp;&amp; current-&gt;forward[lvl]-&gt;value &lt; target)<br>                current = current-&gt;forward[lvl];<br>						<span class="hljs-comment">// 下沉</span><br>        &#125;<br><br>        <span class="hljs-comment">// 在最底层级上找到目标节点</span><br>        current = current-&gt;forward[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">nullptr</span> &amp;&amp; current-&gt;value == target)<br>            <span class="hljs-keyword">return</span> current;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;  <span class="hljs-comment">// 未找到目标节点</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="插入-1"><a href="#插入-1" class="headerlink" title="插入"></a>插入</h3><p><strong>每次有数据要插入时，先通过概率算法告诉我们这个元素需要插入到几级索引中</strong>，然后开始维护索引并把数据插入到原始链表中。</p>
<p>可以实现一个 randomLevel() 方法，该方法会随机生成 1~MAX_LEVEL 之间的数（MAX_LEVEL表示索引的最高层数），且该方法<strong>有 1&#x2F;2 的概率返回 1、1&#x2F;4 的概率返回 2、1&#x2F;8的概率返回 3，以此类推</strong>。</p>
<ul>
<li>randomLevel() 方法返回 1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率 1&#x2F;2）</li>
<li>randomLevel() 方法返回 2 表示当前插入的该元素需要建一级索引（概率 1&#x2F;4）</li>
<li>randomLevel() 方法返回 3 表示当前插入的该元素需要建二级索引（概率 1&#x2F;8）</li>
<li>randomLevel() 方法返回 4 表示当前插入的该元素需要建三级索引（概率 1&#x2F;16）</li>
</ul>
<h3 id="应用：redis有序集合的实现"><a href="#应用：redis有序集合的实现" class="headerlink" title="应用：redis有序集合的实现"></a>应用：redis有序集合的实现</h3><p>Redis 中的有序集合(zset) 支持的操作：</p>
<ol>
<li>插入一个元素</li>
<li>删除一个元素</li>
<li>查找一个元素</li>
<li>有序输出所有元素</li>
<li>按照范围区间查找元素（比如查找值在 [100, 356] 之间的数据）</li>
</ol>
<p>其中，前四个操作红黑树也可以完成，且时间复杂度跟跳表是一样的。但是，按照区间来查找数据这个操作，红黑树的效率没有跳表高。按照区间查找数据时，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了，非常高效。</p>
<h1 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h1><h2 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h2><p>哈希表又称散列表，一种以「key-value」形式存储数据的数据结构。所谓以「key-value」形式存储数据，是指任意的键值 key 都唯一对应到内存中的某个位置。只需要输入查找的键值，就可以快速地找到其对应的 value。</p>
<p>平均情况下，查找、插入和删除的时间复杂度为O(1）。</p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>哈希函数</li>
<li>哈希冲突</li>
<li>哈希桶<ul>
<li>哈希桶（Hash Bucket）是哈希表中存储数据的容器或存储位置。</li>
<li>在哈希表中，通常使用一个数组来表示桶，每个桶可以存储一个或多个键-值对。</li>
<li>哈希函数将键映射到哈希表中的一个索引位置，而该索引位置对应的桶用于存储键-值对。</li>
</ul>
</li>
<li>哈希地址：由哈希函数计算出的桶的位置</li>
<li>负载因子<ul>
<li>哈希表中已存储键-值对数量与哈希表总大小之间的比例关系</li>
<li>负载因子过高时，发生哈希冲突的概率会增加，导致哈希表的性能下降；也会导致内存利用率降低，因为哈希表中的很大一部分空间被浪费在冲突链表上。</li>
<li>负载因子过低时，哈希表会过早地触发扩容操作，浪费内存空间；此外可能导致哈希表频繁地进行扩容操作，对性能造成影响。</li>
</ul>
</li>
</ul>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>根据键值计算索引的函数就叫做哈希函数，也称散列函数。</p>
<h3 id="常见哈希函数"><a href="#常见哈希函数" class="headerlink" title="常见哈希函数"></a>常见哈希函数</h3><ul>
<li>直接地址法（Identity Hash Function）：直接将键转换为哈希表中的索引，适用于键空间比较小且连续的情况。例如，对于整数键，直接使用键作为索引。</li>
<li>取模法（Division Hash Function）：将键除以一个固定的数（通常是哈希表的大小），并取余数作为索引。这种方法简单且常用，但对于某些键分布不均匀的情况可能会导致冲突增多</li>
<li>字符串哈希函数：对于字符串键，可以将字符串的字符转换为对应的整数，然后将这些整数进行加和、乘积或位运算等操作，并最终得到索引。</li>
</ul>
<h3 id="实际应用哈希函数与性能比较"><a href="#实际应用哈希函数与性能比较" class="headerlink" title="实际应用哈希函数与性能比较"></a>实际应用哈希函数与性能比较</h3><p>以下是常用的哈希函数与其性能的比较</p>
<table>
<thead>
<tr>
<th>算法名称</th>
<th>输出大小(bits)</th>
<th>冲突情形</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=HAVAL&amp;action=edit&amp;redlink=1">https://zh.wikipedia.org/w/index.php?title=HAVAL&amp;action=edit&amp;redlink=1</a></td>
<td>256&#x2F;224&#x2F;192&#x2F;160&#x2F;128</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=MD2_(cryptography)&amp;action=edit&amp;redlink=1">https://zh.wikipedia.org/w/index.php?title=MD2_(cryptography)&amp;action=edit&amp;redlink=1</a></td>
<td>128</td>
<td>大多数</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD4">https://zh.wikipedia.org/wiki/MD4</a></td>
<td>128</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MD5">https://zh.wikipedia.org/wiki/MD5</a></td>
<td>128</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=PANAMA&amp;action=edit&amp;redlink=1">https://zh.wikipedia.org/w/index.php?title=PANAMA&amp;action=edit&amp;redlink=1</a></td>
<td>256</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=RadioGat%C3%BAn&amp;action=edit&amp;redlink=1">https://zh.wikipedia.org/w/index.php?title=RadioGat%C3%BAn&amp;action=edit&amp;redlink=1</a></td>
<td>任意长度</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/RIPEMD">https://zh.wikipedia.org/wiki/RIPEMD</a></td>
<td>128</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/RIPEMD">https://zh.wikipedia.org/wiki/RIPEMD</a></td>
<td>128&#x2F;256</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/RIPEMD">https://zh.wikipedia.org/wiki/RIPEMD</a></td>
<td>160&#x2F;320</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-0">https://zh.wikipedia.org/wiki/SHA-0</a></td>
<td>160</td>
<td>是</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-1">https://zh.wikipedia.org/wiki/SHA-1</a></td>
<td>160</td>
<td>有缺陷</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-2">https://zh.wikipedia.org/wiki/SHA-2</a></td>
<td>256&#x2F;224</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/SHA-2">https://zh.wikipedia.org/wiki/SHA-2</a></td>
<td>512&#x2F;384</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=Tiger_(cryptography)&amp;action=edit&amp;redlink=1">https://zh.wikipedia.org/w/index.php?title=Tiger_(cryptography)&amp;action=edit&amp;redlink=1</a></td>
<td>192&#x2F;160&#x2F;128</td>
<td>否</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=WHIRLPOOL&amp;action=edit&amp;redlink=1">https://zh.wikipedia.org/w/index.php?title=WHIRLPOOL&amp;action=edit&amp;redlink=1</a></td>
<td>512</td>
<td>否</td>
</tr>
</tbody></table>
<h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><p>如果对于任意的键值，哈希函数计算出来的索引都不相同，那只用根据索引把 <code>(key, value)</code> 放到对应的位置就行了。但实际上，常常会出现两个不同的键值，他们用哈希函数计算出来的索引是相同的。这时候就需要一些方法来处理冲突。</p>
<h3 id="动态哈希与静态哈希"><a href="#动态哈希与静态哈希" class="headerlink" title="动态哈希与静态哈希"></a>动态哈希与静态哈希</h3><p>静态哈希是指在哈希表创建后，其大小固定不变，无法动态地扩展或收缩。<strong>静态哈希表使用固定数量的桶（或称为槽位）来存储数据。</strong></p>
<p><strong>动态哈希是指在哈希表中允许动态地增加或减少桶的数量，以适应数据集的变化。</strong>当哈希表中的负载因子达到一定阈值时，动态哈希表会自动触发扩展操作，增加桶的数量。同样地，当负载因子过低时，动态哈希表可以自动触发收缩操作，减少桶的数量。</p>
<p>因此，动态哈希和静态哈希采用不同的方式来解决哈希冲突：</p>
<p><strong>静态哈希</strong></p>
<ul>
<li>开放寻址法</li>
</ul>
<p><strong>动态哈希</strong></p>
<ul>
<li>链式法</li>
<li>可扩展的动态散列</li>
<li>线性哈希</li>
</ul>
<h3 id="开放寻址法（Open-Addressing）"><a href="#开放寻址法（Open-Addressing）" class="headerlink" title="开放寻址法（Open Addressing）"></a>开放寻址法（Open Addressing）</h3><p>当发生冲突时，通过一系列的探测方法在哈希表中寻找下一个可用的空闲位置来存储键-值对。常见的探测方法包括：</p>
<ul>
<li>线性探测（逐个向后查找）</li>
<li>二次探测（按平方递增）</li>
<li>双重哈希（使用第二个哈希函数进行步长计算）</li>
<li>Robin Hood Hashing（如果新键-值对的距离小于当前占用槽的键-值对的距离，则新键-值对将取代当前的键-值对，并将其插入到新的位置）</li>
<li>Cuckoo Hashing（将占用的键-值对重新插入到另一个哈希桶中，如果目标哈希桶已经被占用，则会继续将键-值对替换到其他哈希桶，直到找到空的桶为止。）</li>
</ul>
<h3 id="链式法（Chaining）"><a href="#链式法（Chaining）" class="headerlink" title="链式法（Chaining）"></a>链式法（Chaining）</h3><p>每个桶（索引位置）存储一个链表或其他数据结构，当发生冲突时，将冲突的键-值对添加到对应桶的链表中。这样，每个索引位置可以存储多个键-值对，通过遍历链表或其他数据结构，可以找到特定键对应的值。</p>
<p><img src="/images/posts/list/Untitled%205.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="可扩展的动态散列（Extendible-Hashing）"><a href="#可扩展的动态散列（Extendible-Hashing）" class="headerlink" title="可扩展的动态散列（Extendible Hashing）"></a>可扩展的动态散列（Extendible Hashing）</h3><p>为桶引入一间接层，即用一个指向块的指针数组来表示桶，而不是用数据块本身组成的数组来表示桶。</p>
<p>散列函数h为每个键计算出一个K位二进制序列，该K足够大，比如32。</p>
<p>在实际使用时，使用后k位作为key标识，当需要拓展时，k+1。</p>
<p><img src="/images/posts/list/Untitled%206.png" srcset="/img/loading.gif" lazyload></p>
<p><img src="/images/posts/list/Untitled%207.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="线性哈希法（Linear-Hashing）"><a href="#线性哈希法（Linear-Hashing）" class="headerlink" title="线性哈希法（Linear Hashing）"></a>线性哈希法（Linear Hashing）</h3><p>线性哈希是一种动态扩展哈希表的方法，其 “线性” 的名字源于这种方法每次只扩展一个 Bucket 的容量。这种方法需要两个哈希函数。</p>
<p>每次只拓展一个桶，各个桶轮流进行分裂。</p>
<p>其数学原理为：</p>
<blockquote>
<p>如果 <code>Key % n = M</code>，那么 <code>Key % 2n = M 或 M+n</code></p>
</blockquote>
<ol>
<li>哈希表的起始容量为<code>N</code>（N为整数，且为2的 I 次幂，即<code>N=2^&#123;I&#125;</code>），其中N不包括溢出的 Bucket；</li>
<li>给定一个Key，通过哈希函数H()得到一个字节串，我们称该串为R；</li>
<li>我们使用字节串R中的<strong>低 I 位</strong>作为 Bucket 序号，该Bucket负责存储该Key。例如H(2)&#x3D;010，I&#x3D;2，则 Bucket[10] 负责存储(2,Value)；</li>
<li>向已满的 Bucket 中插入数据，会造成“分裂”，我们用一个指针 <code>S</code> 来标识将被分裂的 Bucket；</li>
<li>分裂 Bucket B 时，先建立一个 Bucket B<em>，然后对 B 中的内容进行 rehash，该操作会将其中的内容分配到 B 和 B</em> 两个 Bucket 中。分裂后，标识分裂位置的指针向后移动。</li>
</ol>
<p>线性哈希最重点的一个特点是：被分裂的 Bucket 不一定是溢出Bucket，因为分裂的顺序是线性的（指针 <code>S</code> 的移动是线性的），而且触发分裂的条件可以任意选择。</p>
<p><img src="/images/posts/list/Untitled%208.png" srcset="/img/loading.gif" lazyload></p>
<h2 id="C-中Set与Map的实现"><a href="#C-中Set与Map的实现" class="headerlink" title="C++中Set与Map的实现"></a>C++中Set与Map的实现</h2><p>C++中有以下几种set：</p>
<table>
<thead>
<tr>
<th>集合</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::set</td>
<td>红黑树</td>
<td>有序</td>
<td>否</td>
<td>否</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::multiset</td>
<td>红黑树</td>
<td>有序</td>
<td>是</td>
<td>否</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::unordered_set</td>
<td>哈希表</td>
<td>无序</td>
<td>否</td>
<td>否</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<p>以及以下几种map：</p>
<table>
<thead>
<tr>
<th>映射</th>
<th>底层实现</th>
<th>是否有序</th>
<th>数值是否可以重复</th>
<th>能否更改数值</th>
<th>查询效率</th>
<th>增删效率</th>
</tr>
</thead>
<tbody><tr>
<td>std::map</td>
<td>红黑树</td>
<td>key有序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(logn)</td>
<td>O(logn)</td>
</tr>
<tr>
<td>std::multimap</td>
<td>红黑树</td>
<td>key有序</td>
<td>key可重复</td>
<td>key不可修改</td>
<td>O(log n)</td>
<td>O(log n)</td>
</tr>
<tr>
<td>std::unordered_map</td>
<td>哈希表</td>
<td>key无序</td>
<td>key不可重复</td>
<td>key不可修改</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
</tbody></table>
<h2 id="一致性哈希"><a href="#一致性哈希" class="headerlink" title="一致性哈希"></a>一致性哈希</h2><p><strong>一致性哈希是指将「存储节点」和「数据」都映射到一个首尾相连的哈希环上</strong>。</p>
<p>一致性哈希要进行两步哈希：</p>
<ul>
<li>第一步：对存储节点进行哈希计算，也就是对存储节点做哈希映射，比如根据节点的 IP 地址进行哈希；</li>
<li>第二步：当对数据进行存储或访问时，对数据进行哈希映射；此时数据存储在顺时针方向找到的第一个节点。</li>
</ul>
<p><img src="/images/posts/list/Untitled%209.png" srcset="/img/loading.gif" lazyload></p>
<h3 id="一致性哈希改进：虚拟节点"><a href="#一致性哈希改进：虚拟节点" class="headerlink" title="一致性哈希改进：虚拟节点"></a>一致性哈希改进：虚拟节点</h3><p><strong>不再将真实节点映射到哈希环上，而是将虚拟节点映射到哈希环上，并将虚拟节点映射到实际节点，所以这里有「两层」映射关系。</strong></p>
<p><img src="/images/posts/list/Untitled%2010.png" srcset="/img/loading.gif" lazyload></p>
<ul>
<li>虚拟节点增加节点数量，使节点在哈希环上的分布更加均匀</li>
<li>节点变化时，会有不同的节点分担系统的变化，稳定性更高</li>
</ul>
<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><p>我们通常说的堆指的是二叉堆。</p>
<h2 id="二叉堆定义"><a href="#二叉堆定义" class="headerlink" title="二叉堆定义"></a>二叉堆定义</h2><p>二叉堆是一棵完全二叉树，每个节点的键值都大于等于&#x2F;小于等于其父亲的键值。</p>
<p>每个节点的键值都大于等于其父亲键值的堆叫做最小堆，否则叫做最大堆。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><h3 id="Heapify（堆化）"><a href="#Heapify（堆化）" class="headerlink" title="Heapify（堆化）"></a>Heapify（堆化）</h3><p>堆化即将一个无序数组转化为堆的过程，由于我们讨论的堆都是完全二叉树，因此可以使用数组来表示，对于节点i，其左子节点为2i，右子节点为2i+1，父节点为[i&#x2F;2] </p>
<p>最小堆化的过程如下：</p>
<p>从第一个非叶子节点开始，依次向下进行下面的操作：</p>
<ul>
<li>将当前节点标记为父节点。</li>
<li>比较父节点与其左右子节点的值，找到最小的节点。</li>
<li>如果最小节点不是父节点本身，则交换父节点与最小节点的值。</li>
<li>将最小节点作为新的父节点，重复上述步骤直到当前节点为叶子节点。</li>
</ul>
<p>用伪代码描述如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 建立最小堆</span><br><span class="hljs-function">function <span class="hljs-title">buildMinHeap</span><span class="hljs-params">(array)</span>:</span><br><span class="hljs-function">    n =</span> <span class="hljs-built_in">length</span>(array)<br>		<span class="hljs-comment">// 第一个非叶子节点</span><br>    start = <span class="hljs-built_in">floor</span>(n/<span class="hljs-number">2</span>) - <span class="hljs-number">1</span><br>    <br>    <span class="hljs-keyword">for</span> i from start down to <span class="hljs-number">0</span>:<br>        <span class="hljs-built_in">heapify</span>(array, n, i)<br><br><span class="hljs-comment">// 进行堆化操作</span><br>function <span class="hljs-built_in">heapify</span>(array, n, i):<br>    smallest = i<br>    left = <span class="hljs-number">2</span>*i + <span class="hljs-number">1</span><br>    right = <span class="hljs-number">2</span>*i + <span class="hljs-number">2</span><br>    <br>    <span class="hljs-keyword">if</span> left &lt; n <span class="hljs-keyword">and</span> array[left] &lt; array[smallest]:<br>        smallest = left<br>        <br>    <span class="hljs-keyword">if</span> right &lt; n <span class="hljs-keyword">and</span> array[right] &lt; array[smallest]:<br>        smallest = right<br>    <br>		<span class="hljs-comment">// 如果把父节点交换下去了，那么要继续堆化</span><br>    <span class="hljs-keyword">if</span> smallest != i:<br>        <span class="hljs-built_in">swap</span>(array, i, smallest)<br>        <span class="hljs-built_in">heapify</span>(array, n, smallest)<br></code></pre></td></tr></table></figure>

<h3 id="堆的插入和删除"><a href="#堆的插入和删除" class="headerlink" title="堆的插入和删除"></a>堆的插入和删除</h3><p>当实现堆化后，堆的插入与删除都可以在其基础上实现</p>
<p>堆的插入步骤为：</p>
<ul>
<li>将新元素插入到最后</li>
<li>对堆进行堆化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">If there is no node, <br>  create a newNode.<br><span class="hljs-keyword">else</span> (a node is already present)<br>  insert the newNode at the <span class="hljs-built_in">end</span> (last node from left to right.)<br>  <br>heapify the array<br></code></pre></td></tr></table></figure>

<p>堆的删除步骤为：</p>
<ul>
<li>找到需要删除的节点</li>
<li>和最后一个节点交换并删除</li>
<li>对堆进行堆化</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp">If nodeToBeDeleted is the leafNode<br>  remove the node<br>Else swap nodeToBeDeleted with the lastLeafNode<br>  remove noteToBeDeleted<br>   <br>heapify the array<br></code></pre></td></tr></table></figure>

<h2 id="拓展：Fibonacci堆"><a href="#拓展：Fibonacci堆" class="headerlink" title="拓展：Fibonacci堆"></a>拓展：Fibonacci堆</h2><p>斐波那契堆 <code>Fibonacci Heap</code> ：是一系列具有最小堆序 <code>min-heap ordered</code> 的有根树的集合。也就是说，每棵树都遵循最小堆性质 <code>min-heap property</code>：每个节点的关键字大于或等于它的父节点的关键字。</p>
<p><img src="/images/posts/list/Untitled%2011.png" srcset="/img/loading.gif" lazyload></p>
<p>斐波那契堆的重要特性包括：</p>
<ol>
<li>它是一组由最小堆组成的集合。</li>
<li>在斐波那契堆中维护了一个指向最小元素节点的指针。</li>
<li>它由一组标记节点组成。</li>
<li>斐波那契堆中的树是无序但有根的。</li>
</ol>
<p>其操作主要包括：</p>
<ul>
<li>插入（Insert）：将一个新元素插入到堆中。</li>
<li>删除最小节点（ExtractMin）：删除并返回堆中的最小节点。</li>
<li>减小键值（DecreaseKey）：将堆中某个节点的键值减小，并相应地调整堆的结构以维持最小堆性质。</li>
<li>合并（Union）：将两个斐波那契堆合并成一个堆。</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/DSA/">#DSA</a>
      
        <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/">#哈希表</a>
      
        <a href="/tags/%E9%93%BE%E8%A1%A8/">#链表</a>
      
        <a href="/tags/%E5%A0%86/">#堆</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>小星学DSA丨链表、哈希表与堆</div>
      <div>http://rainystar.site/2023/06/27/10-55-00/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>小星</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年6月27日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/19/10-40-00/" title="Leetcode图专题总结">
                        <span class="hidden-mobile">Leetcode图专题总结</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
